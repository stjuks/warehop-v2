/**
 * Returns a type without the promise wrapper.
 */
export declare type WithoutPromise<T> = T extends Promise<infer P> ? P : T;
/**
 * Task status.
 */
export declare type TaskStatus = 'pending' | 'resolved' | 'rejected';
/**
 * Task function signature.
 */
export declare type TaskFunc<A extends any[], R> = (...args: A) => Promise<R>;
/**
 * Task options.
 */
export interface TaskOptions<A extends any[], R> {
    state?: TaskStatus;
    error?: unknown;
    result?: WithoutPromise<R>;
    args?: A;
    swallow?: boolean;
}
/**
 * Object type used for pattern matching.
 */
export interface TaskMatchProps<T1, T2, T3, A extends any[], R = any> {
    pending?: (...args: A) => T1;
    rejected?: (error: unknown) => T2;
    resolved?: (result: WithoutPromise<R>) => T3;
}
/**
 * Task state.
 */
export interface TaskState<A extends any[], R> {
    /**
     * The status (resolved, rejected, pending)
     */
    readonly state: TaskStatus;
    /**
     * Convenience getter for `state === 'pending'`.
     */
    readonly pending: boolean;
    /**
     * Convenience getter for `state === 'resolved'`.
     */
    readonly resolved: boolean;
    /**
     * Convenience getter for `state === 'rejected'`.
     */
    readonly rejected: boolean;
    /**
     * The last arguments passed to the task.
     */
    readonly args: A;
    /**
     * The result of the last invocation.
     */
    readonly result?: WithoutPromise<R>;
    /**
     * The error of the last failed invocation.
     */
    readonly error?: unknown;
}
/**
 * Task methods.
 */
export interface TaskMethods<A extends any[], R> {
    /**
     * Pattern-matches on the task status.
     * @param props
     */
    match<PT, ET, RT>(props: TaskMatchProps<PT, ET, RT, A, R>): PT | ET | RT;
    /**
     * Wraps the task by invoking `func` with the inner task function, which returns the wrapped function
     * and converts that to a task.
     *
     * @param func
     */
    wrap<NA extends any[], NR>(func: (inner: (...args: A) => R) => (...args: NA) => NR): Task<NA, NR>;
    /**
     * Sets the state.
     */
    setState(props: TaskOptions<A, R>): void;
    /**
     * Resets the state.
     */
    reset(): void;
}
/**
 * Task function, state and methods.
 */
export declare type Task<A extends any[], R> = TaskFunc<A, WithoutPromise<R>> & TaskState<A, R> & TaskMethods<A, R>;
/**
 * Actual task factory.
 */
export interface TaskCreator<K extends keyof TaskOptions<any, any>> extends MethodDecorator, PropertyDecorator {
    /**
     * Calls the actual task function.
     */
    <A extends any[], R>(func: (...args: A) => R, options?: Pick<TaskOptions<A, R>, K>): Task<A, R>;
    (options: Pick<TaskOptions<any, any>, K>): PropertyDecorator;
    (options: Pick<TaskOptions<any, any>, K>): MethodDecorator;
}
export interface TaskFactory extends TaskCreator<keyof TaskOptions<any, any>> {
    /**
     * Creates a task in the `resolved` state.
     */
    resolved: TaskCreator<Exclude<keyof TaskOptions<any, any>, 'state'>>;
    /**
     * Creates a task in the `rejected` state.
     */
    rejected: TaskCreator<Exclude<keyof TaskOptions<any, any>, 'state'>>;
}
/**
 * Creates a task in the `pending` state.
 */
declare const task: TaskFactory;
export { task };
